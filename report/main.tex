\documentclass[a4paper, twocolumn, 11pt, twoside]{article}
\usepackage[english]{babel} %language
\usepackage[utf8]{inputenc} %input encoding
\usepackage{float} %position of floating objects
\usepackage{bookmark} %hyperlinks in pdf
\usepackage{subcaption}
\usepackage[T1]{fontenc}
\usepackage{lipsum} %placeholder text
\usepackage{amsthm} %theorems
\usepackage{amsmath}
\usepackage{mathtools}
% \usepackage{physics}
% \usepackage{xcolor}
% \usepackage{graphicx}
% \usepackage[left=23mm,right=13mm,top=35mm,columnsep=15pt]{geometry} 
% \usepackage{adjustbox}
% \usepackage{placeins}
% \usepackage{csquotes}
% \usepackage{algorithm} 
% \usepackage{algpseudocode}
% \usepackage{listings}
% \usepackage{graphicx}
% \usepackage{tikz}
% \usepackage[normalem]{ulem}
% \useunder{\uline}{\ul}{}

\title{Long-Horizon Vehicle Motion Planning and Control Through Serially Cascaded Model Complexity}
\author{}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
    We propose the implementation and experimentation of a motion planning and
    control framework for autonomous vehicles based on nonlinear
    model-predictive control.The work is mainly based on \cite{paper}. The code is available publicly at
    \href{https://github.com/neverorfrog/vehicle-control}{this GitHub
    repository}. 
\end{abstract}


\section*{Introduction}

% Using the star (*) form of the sectioning command suppresses the numbering for
% that particular section or subsection.
Model predictive control (MPC for short) is a control technique which, in closed-loop,
computes the control inputs by means of an optimization algorithm, which uses a
\textbf{model} of the system and measurements to \textbf{predict} future states and act
accordingly by choosing the "best" control action. 

\begin{equation}
\begin{aligned}
    \min_{u_0,...,u_{N-1}}{J(x,u)} \\
    \text{ subject to }
        \quad x_{k+1} = f(x_k,u_k) \\
        \quad x_0 = x(t)
        \quad 
\end{aligned}
\end{equation}

We call $J(x)$ the \textbf{cost function} and $g(x)$ the \textbf{constraints}.
In particular, the sequence of control actions is generated such that the cost
function is minimized over the \textbf{prediction horizon} by solving a
constrained optimization problem that depends on the evolution of the model over
the horizon itself. Then, the controller applies just the first action: in this
way the system has advanced one step, a new optimization problem with a new
initial state is produced, and the process goes on. The advantages of MPC are
many: it is a multivaribale controller, so it can control outputs by handling
simultaneously all the interactions between system variables; it can handle
constraints, so it allows to avoid possible undesired states; it predicts the
future states, allowing to incorporate their information in the actual control.
It is particulary useful for a real-time control that adapts to \textbf{changes
in the environment}.\\
When dealing with nonlinear dynamics, a nonlinear MPC (or NMPC) can be used to
capture more accurately the nonlinear behavior of a system. This entails a more
robust manipulation of both nonlinearities and uncertainties in dynamics models
and constraints. However, one of its highest problem is the computational power
it can require, especially when dealing with highly nonlinear systems. This
entails the need of a high-performance hardware to solve the optimization
problem in an acceptable time, but sometimes this is not enough. Especially in a
real environment, where the timeliness is fundamental to take a decision, fast
computations are of utmost importance.\\
The purpose of \cite{paper} is to develop a novel approach for a real-time NMPC
for an autonomous vehicle, which was tested in a race environment, where the
objective was to complete a lap in the minimum possible time, while also
enhancing computational efficiency. The architecture is a cascaded model
composed by a detailed model of the car for the near term, and a less complex
model used for a long horizon planning. This concept will be addressed more in
detail.\\
In this report we tried to replicate the architecture of the paper, and we
tested it in a simulation environment we created. Our purpose was to show the
mean computation time for the cascaded model is lower than the mean computation
time for a complete detailed model, achieving also better results.

\subsection*{Report outline}

\section*{Related Work}


\section*{Methodology}

\begin{itemize}
    \item Overview/Introduction
    \begin{itemize}
        \item Concept of MPC for vehicle control
        \item Concept of serially cascaded models 
    \end{itemize}

    \item Paper
    \begin{itemize}
        \item Vehicle dynamic models
        \item NLP
    \end{itemize}    
\end{itemize}

\section*{Serially cascaded models}
While a single control loop system is a simple structure that consists in
just one primary loop that regulates directly the system, the cascade control
makes use of multiple control loops nested within each other. The requirements
for an effective cascade control are that the inner loops variables must be 
faster-responding than the outer ones, and the major disturbances enter in the 
inner loops. Considering the simplest cascade control structure,\\
... (aggiungi schema/equazioni generiche del cascade semplice)

According to the control objectives, a cascade control scheme can include also 
more than one model in its control loops, such that each model capture different
relevant dynamics meeting different control tasks. In this way there is not the 
need to use a high-fidelity model for every objective, because some of them can 
be achieved considering simpler dynamic models. Furthermore, in optimal control
the usage of detailed models for long horizon can bring to an explosion of the 
complexity of the problem; instead, using more detailed models for near terms 
to have a high-fidelity of the real robot, and easier models for planning purpose
in long terms, allows to achieve good performances with computational limits.

When dealing with more than one dynamic model with different dynamic speeds,
the main advantage of a cascade control scheme is the higher performace with respect
to a simple single control loop, thanks to the possibility to control disturbances
in the inner loop before they affect the outer one. The main problem this architecture
can face is in the interaction between the control loops, where the reference signals 
generated by a control loop are not achievable by the others. This happens especially
when we are dealing with models with different complexity levels.

To deal with the disadvantages of the cascade control design, but leveraging on its 
strengths, the idea of \cite{paper} in the scenario of an autonomous car is to build 
a serial architecture which contains two dynamic models, belonging to the same single
control loop and the same prediction horizon. The first one is a single-track vehicle
model, which reflects comprehensively the complex dynamic of the car (we will see in the 
next section the details) and provides all the tools to accurately treat the first
prediction steps. The farthest window of the horizon is treated with a planar point-mass 
model, useful for long-term trajectory planning with low computational resources.
Thus the benefits of the cascade model for the trajectory task are preserved; moreover
the existance of a single control loop ensure the feasibility of the reference targets
that are exchanged between the two models. A very important thing to pay attention is 
in the linkage of the plant models, propagating correctly the final state of the first
model to the initial state of the second model, and mantaining consistency in constraints
and cost functions across interconnected models.




\section*{Implementation}

\begin{itemize}
    \item Tools and libraries
    \item Description of implementation process
    \item Modifications or adaptations wrt the paper
\end{itemize}

\section*{Experimental Setup}

\begin{itemize}
    \item Simulation setting (track etc.)
    \item Different configuration scenarios
\end{itemize}

\section*{Results}

\begin{itemize}
    \item Guess what
\end{itemize}

\section*{Conclusion}

\begin{itemize}
    \item Take-away message
    \item Pitfalls and future work
\end{itemize}


\bibliographystyle{apalike}
\bibliography{references}
\end{document}
